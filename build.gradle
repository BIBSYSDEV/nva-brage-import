plugins {
    id 'java'
    id 'jacoco'
    id 'checkstyle'
    id 'pmd'
    id 'base'
    id 'nebula.lint' version '16.9.1'
    id 'com.github.johnrengelman.shadow' version '6.1.0'
}
def jacksonVersion = '2.12.0'
def junitVersion = '5.7.0'
def dataModelVersion = '0.11.5'

dependencies {
    implementation project(path: ':dublin-core', configuration: 'shadow')
    implementation project(path: ':import-brage', configuration: 'shadow')
    implementation project(path: ':nsd-dbh-import', configuration: 'shadow')
    implementation group: 'com.github.BIBSYSDEV', name: 'nva-datamodel-java', version: dataModelVersion
    implementation group: 'com.github.BIBSYSDEV', name: 'nva-commons', version: '0.7.3'
    implementation group: 'info.picocli', name: 'picocli', version: '4.5.2'

    implementation group: 'org.apache.commons', name: 'commons-csv', version: '1.8'
    implementation group: 'commons-validator', name: 'commons-validator', version: '1.7'
    implementation group: 'com.github.pemistahl', name: 'lingua', version: '1.0.3'

    implementation group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version: jacksonVersion
    implementation group: 'com.fasterxml.jackson.dataformat', name: 'jackson-dataformat-xml', version: jacksonVersion
    implementation group: 'com.fasterxml.jackson.core', name: 'jackson-core', version: jacksonVersion
    testImplementation group: 'org.hamcrest', name: 'hamcrest', version: '2.1'
    testImplementation group: 'org.hamcrest', name: 'hamcrest-library', version: '2.1'
    testImplementation group: 'org.junit.jupiter', name: 'junit-jupiter-api', version: junitVersion
    testImplementation group: 'org.junit.jupiter', name: 'junit-jupiter-params', version: junitVersion
    testRuntimeOnly group: 'org.junit.jupiter', name: 'junit-jupiter-engine'
}

pmd {
    ruleSetConfig = rootProject.resources.text.fromFile('config/pmd/ruleset.xml')
    ruleSets = []
    ignoreFailures true // should be false
}

allprojects {

    apply plugin: 'base'
    apply plugin: 'nebula.lint'

    gradleLint {
        rules = ['unused-dependency']
    }

    repositories {
        jcenter()
        mavenCentral()
        maven { url "https://jitpack.io" }
    }
}

subprojects {

    apply plugin: 'java'
    apply plugin: 'jacoco'
    apply plugin: 'checkstyle'
    apply plugin: 'pmd'
    apply plugin: 'com.github.johnrengelman.shadow'

    project.ext.junitVersion = junitVersion
    project.ext.dataModelVersion = dataModelVersion
    project.ext.jacksonVersion = jacksonVersion

    dependencies {
        def log4jVersion = '2.14.0'
        implementation group: 'com.github.BIBSYSDEV', name: 'nva-datamodel-java', version: project.ext.dataModelVersion
        implementation group: 'org.apache.logging.log4j', name: 'log4j-api', version: log4jVersion
        implementation group: 'org.apache.logging.log4j', name: 'log4j-core', version: log4jVersion
        implementation group: 'org.apache.logging.log4j', name: 'log4j-slf4j-impl', version: log4jVersion

        implementation group: 'org.apache.commons', name: 'commons-csv', version: '1.8'
        implementation group: 'commons-validator', name: 'commons-validator', version: '1.7'
        implementation group: 'com.github.pemistahl', name: 'lingua', version: '1.0.3'

        implementation group: 'com.github.BIBSYSDEV', name: 'nva-commons', version: '0.7.3'
        testImplementation group: 'org.hamcrest', name: 'hamcrest', version: '2.1'
        testImplementation group: 'org.hamcrest', name: 'hamcrest-library', version: '2.1'
        testImplementation group: 'org.junit.jupiter', name: 'junit-jupiter-api', version: project.ext.junitVersion
        testImplementation group: 'org.junit.jupiter', name: 'junit-jupiter-params', version: project.ext.junitVersion
        testRuntimeOnly group: 'org.junit.jupiter', name: 'junit-jupiter-engine'
    }

    test {

        useJUnitPlatform()
        failFast = false
        testLogging {
            events = ['skipped', 'passed', 'failed']
        }
        finalizedBy jacocoTestReport

        jacocoTestReport {
            reports {
                xml.enabled true
            }
        }

        pmd {
            ruleSetConfig = rootProject.resources.text.fromFile('config/pmd/ruleset.xml')
            ruleSets = []
            ignoreFailures true // should be false
        }

        checkstyle {
            configFile = rootProject.resources.text.fromFile('config/checkstyle/checkstyle.xml').asFile()
            showViolations true
        }

        tasks.withType(Checkstyle) {
            reports {
                xml.enabled false
                html.enabled true
                html.stylesheet = rootProject.resources.text.fromFile('config/checkstyle/checkstyle-simple.xsl')
            }
        }

        check.dependsOn(jacocoTestCoverageVerification)
        jacocoTestCoverageVerification.dependsOn(jacocoTestReport)

        jacocoTestCoverageVerification {
            violationRules {
                rule {
                    limit {
                        counter = 'METHOD'
                        value = 'COVEREDRATIO'
                        minimum = 0.000
                    }
                }
                rule {
                    limit {
                        counter = 'CLASS'
                        value = 'COVEREDRATIO'
                        minimum = 0.000
                    }
                }
            }
        }
    }
}


def getProjectList() {
    // These projects are considered. Replace with a different list as needed.
    subprojects + project
}

task jacocoMerge(type: JacocoMerge) {
    group = LifecycleBasePlugin.VERIFICATION_GROUP
    description = 'Merge the JaCoCo data files from all subprojects into one'
    project.afterEvaluate {  // do it at the end of the config phase to be sure all information is present
        FileCollection execFiles = project.objects.fileCollection()   // an empty FileCollection
        getProjectList().each { Project subproject ->
            if (subproject.pluginManager.hasPlugin('jacoco')) {
                def testTasks = subproject.tasks.withType(Test)
                dependsOn(testTasks)   // ensure that .exec files are actually present

                testTasks.each { Test task ->
                    // The JacocoTaskExtension is the source of truth for the location of the .exec file.
                    JacocoTaskExtension extension = task.getExtensions().findByType(JacocoTaskExtension.class)
                    if (extension != null) {
                        execFiles.from extension.getDestinationFile()
                    }
                }
            }
        }
        executionData = execFiles
    }
    doFirst {
        // .exec files might be missing if a project has no tests. Filter in execution phase.
        executionData = executionData.filter { it.canRead() }
    }
}

def getReportTasks(JacocoReport pRootTask) {
    getProjectList().collect {
        it.tasks.withType(JacocoReport).findAll { it != pRootTask }
    }.flatten()
}

task jacocoRootReport(type: JacocoReport, dependsOn: tasks.jacocoMerge) {
    group = LifecycleBasePlugin.VERIFICATION_GROUP
    description = 'Generates an aggregate report from all subprojects'

    logger.lifecycle 'Using aggregated file: ' + tasks.jacocoMerge.destinationFile
    executionData.from tasks.jacocoMerge.destinationFile

    project.afterEvaluate {
        // The JacocoReport tasks are the source of truth for class files and sources.
        def reportTasks = getReportTasks(tasks.jacocoRootReport)
        classDirectories.from project.files({
            reportTasks.collect {it.classDirectories}.findAll {it != null}
        })
        sourceDirectories.from project.files({
            reportTasks.collect {it.sourceDirectories}.findAll {it != null}
        })
    }

    reports {
        xml.enabled true
    }
}

build {
    dependsOn jacocoRootReport
}

jar {
    manifest {
        attributes(

                "Implementation-Title": "brage-import",
                "Implementation-version": 1.0,
                "Main-Class": "no.unit.nva.brage.importer.ImportCli"
        )
    }
}
